pipeline {
    agent any
    
    environment {
        // Application settings
        APP_NAME = 'test-asg-server'
        DOCKER_IMAGE = "${APP_NAME}:${BUILD_NUMBER}"
        DOCKER_LATEST = "${APP_NAME}:latest"
        
        // Environment-specific variables will be injected per stage
        NODE_ENV = 'development'
        PORT = '5000'
        LOG_LEVEL = 'info'
        
        // Build metadata
        BUILD_TIMESTAMP = sh(script: 'date -u +"%Y-%m-%dT%H:%M:%SZ"', returnStdout: true).trim()
        GIT_COMMIT_SHORT = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
    }
    
    parameters {
        choice(
            name: 'DEPLOY_ENV',
            choices: ['none', 'staging', 'production'],
            description: 'Environment to deploy to'
        )
        booleanParam(
            name: 'SKIP_TESTS',
            defaultValue: false,
            description: 'Skip test execution'
        )
        booleanParam(
            name: 'FORCE_REBUILD',
            defaultValue: false,
            description: 'Force rebuild Docker image'
        )
    }
    
    stages {
        stage('Environment Setup') {
            steps {
                script {
                    echo "üöÄ Starting CI/CD Pipeline"
                    echo "üì¶ Application: ${APP_NAME}"
                    echo "üî® Build Number: ${BUILD_NUMBER}"
                    echo "üìÖ Build Time: ${BUILD_TIMESTAMP}"
                    echo "üîó Git Commit: ${GIT_COMMIT_SHORT}"
                    echo "üåç Target Environment: ${params.DEPLOY_ENV}"
                    
                    // Set environment-specific variables
                    if (params.DEPLOY_ENV == 'production') {
                        env.NODE_ENV = 'production'
                        env.LOG_LEVEL = 'warn'
                        env.ENABLE_CONSOLE_LOGGING = 'false'
                        env.ENABLE_METRICS = 'true'
                    } else if (params.DEPLOY_ENV == 'staging') {
                        env.NODE_ENV = 'staging'
                        env.LOG_LEVEL = 'debug'
                        env.ENABLE_CONSOLE_LOGGING = 'true'
                        env.ENABLE_METRICS = 'true'
                    } else {
                        env.NODE_ENV = 'development'
                        env.LOG_LEVEL = 'info'
                        env.ENABLE_CONSOLE_LOGGING = 'true'
                        env.ENABLE_METRICS = 'false'
                    }
                }
            }
        }
        
        stage('Checkout') {
            steps {
                echo 'üì• Checking out source code...'
                checkout scm
                
                script {
                    // Create build info file
                    writeFile file: 'build-info.json', text: '''\n                    {\n                        \"buildNumber\": \"''' + BUILD_NUMBER + '''\",\n                        \"buildTimestamp\": \"''' + BUILD_TIMESTAMP + '''\",\n                        \"gitCommit\": \"''' + GIT_COMMIT_SHORT + '''\",\n                        \"environment\": \"''' + env.NODE_ENV + '''\",\n                        \"version\": \"1.0.0\"\n                    }\n                    '''\n                }\n            }\n        }\n        \n        stage('Install Dependencies') {\n            steps {\n                echo 'üì¶ Installing Node.js dependencies...'\n                sh '''\n                    echo \"Node.js version: $(node --version)\"\n                    echo \"NPM version: $(npm --version)\"\n                    echo \"Environment: ${NODE_ENV}\"\n                    \n                    # Install dependencies\n                    npm ci\n                    \n                    # Verify installation\n                    npm list --depth=0 || true\n                '''\n            }\n        }\n        \n        stage('Environment Configuration') {\n            parallel {\n                stage('Development Config') {\n                    when {\n                        expression { env.NODE_ENV == 'development' }\n                    }\n                    steps {\n                        script {\n                            writeFile file: '.env.pipeline', text: '''\nNODE_ENV=development\nPORT=5000\nAPP_NAME=test-asg-server\nAPP_VERSION=1.0.0-dev\nLOG_LEVEL=info\nENABLE_CONSOLE_LOGGING=true\nENABLE_CORS=true\nCORS_ORIGIN=*\nENABLE_METRICS=false\n'''\n                            echo '‚öôÔ∏è Development configuration applied'\n                        }\n                    }\n                }\n                \n                stage('Staging Config') {\n                    when {\n                        expression { env.NODE_ENV == 'staging' }\n                    }\n                    steps {\n                        script {\n                            writeFile file: '.env.pipeline', text: '''\nNODE_ENV=staging\nPORT=5000\nAPP_NAME=test-asg-server\nAPP_VERSION=1.0.0-staging\nLOG_LEVEL=debug\nENABLE_CONSOLE_LOGGING=true\nENABLE_CORS=true\nCORS_ORIGIN=https://staging.yourdomain.com\nENABLE_METRICS=true\nMETRICS_PORT=9090\n'''\n                            echo '‚öôÔ∏è Staging configuration applied'\n                        }\n                    }\n                }\n                \n                stage('Production Config') {\n                    when {\n                        expression { env.NODE_ENV == 'production' }\n                    }\n                    steps {\n                        script {\n                            writeFile file: '.env.pipeline', text: '''\nNODE_ENV=production\nPORT=5000\nAPP_NAME=test-asg-server\nAPP_VERSION=1.0.0\nLOG_LEVEL=warn\nENABLE_CONSOLE_LOGGING=false\nENABLE_CORS=false\nCORS_ORIGIN=https://yourdomain.com\nENABLE_METRICS=true\nMETRICS_PORT=9090\n'''\n                            echo '‚öôÔ∏è Production configuration applied'\n                        }\n                    }\n                }\n            }\n        }\n        \n        stage('Code Quality & Security') {\n            parallel {\n                stage('Lint & Format') {\n                    steps {\n                        echo 'üîç Running code quality checks...'\n                        sh '''\n                            # Run linting (if configured)\n                            npm run lint || echo \"No linting configured\"\n                            \n                            # Check package.json format\n                            cat package.json | python -m json.tool > /dev/null && echo \"‚úÖ package.json is valid JSON\"\n                        '''\n                    }\n                }\n                \n                stage('Security Audit') {\n                    steps {\n                        echo 'üîí Running security audit...'\n                        sh '''\n                            # NPM security audit\n                            npm audit --audit-level=high || echo \"‚ö†Ô∏è Security audit completed with warnings\"\n                            \n                            # Check for sensitive files\n                            if [ -f \".env\" ]; then\n                                echo \"‚ö†Ô∏è Warning: .env file found in repository\"\n                            fi\n                        '''\n                    }\n                }\n                \n                stage('Dependency Check') {\n                    steps {\n                        echo 'üìã Checking dependencies...'\n                        sh '''\n                            # List outdated packages\n                            npm outdated || true\n                            \n                            # Check for unused dependencies\n                            echo \"Installed packages:\"\n                            npm list --depth=0 || true\n                        '''\n                    }\n                }\n            }\n        }\n        \n        stage('Test') {\n            when {\n                not { params.SKIP_TESTS }\n            }\n            steps {\n                echo 'üß™ Running tests...'\n                script {\n                    sh '''\n                        # Set test environment\n                        export NODE_ENV=test\n                        export PORT=5001\n                        \n                        # Run tests (if configured)\n                        npm test || echo \"No tests configured yet\"\n                        \n                        # Basic application smoke test\n                        echo \"Starting application for smoke test...\"\n                        timeout 30s npm start &\n                        APP_PID=$!\n                        \n                        # Wait for app to start\n                        sleep 5\n                        \n                        # Test health endpoint\n                        curl -f http://localhost:5001/health || {\n                            echo \"‚ùå Health check failed\"\n                            kill $APP_PID || true\n                            exit 1\n                        }\n                        \n                        echo \"‚úÖ Smoke test passed\"\n                        kill $APP_PID || true\n                    '''\n                }\n            }\n        }\n        \n        stage('Build Docker Image') {\n            steps {\n                echo 'üê≥ Building Docker image...'\n                script {\n                    sh '''\n                        # Copy pipeline environment file\n                        if [ -f \".env.pipeline\" ]; then\n                            cp .env.pipeline .env.docker\n                        fi\n                        \n                        # Build Docker image with build args\n                        docker build \\\n                            --build-arg NODE_ENV=${NODE_ENV} \\\n                            --build-arg BUILD_NUMBER=${BUILD_NUMBER} \\\n                            --build-arg GIT_COMMIT=${GIT_COMMIT_SHORT} \\\n                            --tag ${DOCKER_IMAGE} \\\n                            --tag ${DOCKER_LATEST} \\\n                            .\n                        \n                        # Inspect image\n                        docker images ${APP_NAME}\n                        docker inspect ${DOCKER_IMAGE} | grep -A 5 \"Config\"\n                    '''\n                }\n            }\n        }\n        \n        stage('Container Security Scan') {\n            steps {\n                echo 'üîí Scanning Docker image for vulnerabilities...'\n                script {\n                    sh '''\n                        # Docker image vulnerability scan (if trivy is available)\n                        if command -v trivy &> /dev/null; then\n                            echo \"Running Trivy security scan...\"\n                            trivy image --exit-code 1 --severity HIGH,CRITICAL ${DOCKER_IMAGE} || {\n                                echo \"‚ö†Ô∏è Security vulnerabilities found\"\n                                trivy image --severity HIGH,CRITICAL ${DOCKER_IMAGE}\n                            }\n                        else\n                            echo \"Trivy not available, skipping security scan\"\n                        fi\n                        \n                        # Basic image inspection\n                        docker history ${DOCKER_IMAGE}\n                    '''\n                }\n            }\n        }\n        \n        stage('Integration Tests') {\n            steps {\n                echo 'üîÑ Running integration tests...'\n                script {\n                    sh '''\n                        # Start container with pipeline environment\n                        docker run -d \\\n                            --name test-container-${BUILD_NUMBER} \\\n                            --env-file .env.pipeline \\\n                            -p 5000:5000 \\\n                            ${DOCKER_IMAGE}\n                        \n                        # Wait for container to be healthy\n                        echo \"Waiting for container to start...\"\n                        sleep 10\n                        \n                        # Verify container is running\n                        docker ps | grep test-container-${BUILD_NUMBER}\n                        \n                        # Test all endpoints\n                        echo \"Testing health endpoint...\"\n                        curl -f http://localhost:5000/health | jq .\n                        \n                        echo \"Testing root endpoint...\"\n                        curl -f http://localhost:5000/ | jq .\n                        \n                        echo \"Testing API endpoints...\"\n                        curl -f http://localhost:5000/api/users | jq .\n                        \n                        # Test environment configuration\n                        HEALTH_RESPONSE=$(curl -s http://localhost:5000/health)\n                        ACTUAL_ENV=$(echo $HEALTH_RESPONSE | jq -r '.environment')\n                        \n                        if [ \"$ACTUAL_ENV\" = \"${NODE_ENV}\" ]; then\n                            echo \"‚úÖ Environment configuration verified: $ACTUAL_ENV\"\n                        else\n                            echo \"‚ùå Environment mismatch: expected ${NODE_ENV}, got $ACTUAL_ENV\"\n                            exit 1\n                        fi\n                        \n                        echo \"‚úÖ All integration tests passed\"\n                    '''\n                }\n            }\n            post {\n                always {\n                    sh '''\n                        # Cleanup test container\n                        docker logs test-container-${BUILD_NUMBER} || true\n                        docker stop test-container-${BUILD_NUMBER} || true\n                        docker rm test-container-${BUILD_NUMBER} || true\n                    '''\n                }\n            }\n        }\n        \n        stage('Deploy to Staging') {\n            when {\n                expression { params.DEPLOY_ENV == 'staging' }\n            }\n            steps {\n                echo 'üöÄ Deploying to staging environment...'\n                script {\n                    sh '''\n                        # Stop existing staging container\n                        docker stop ${APP_NAME}-staging || true\n                        docker rm ${APP_NAME}-staging || true\n                        \n                        # Deploy to staging with staging environment\n                        docker run -d \\\n                            --name ${APP_NAME}-staging \\\n                            --env-file .env.staging \\\n                            -p 5001:5000 \\\n                            --restart unless-stopped \\\n                            ${DOCKER_IMAGE}\n                        \n                        # Wait for deployment\n                        sleep 10\n                        \n                        # Verify staging deployment\n                        curl -f http://localhost:5001/health | jq .\n                        \n                        echo \"‚úÖ Staging deployment successful!\"\n                        echo \"üåê Staging URL: http://localhost:5001\"\n                    '''\n                }\n            }\n        }\n        \n        stage('Deploy to Production') {\n            when {\n                expression { params.DEPLOY_ENV == 'production' }\n            }\n            steps {\n                script {\n                    timeout(time: 5, unit: 'MINUTES') {\n                        input message: 'Deploy to production?', ok: 'Deploy',\n                              submitterParameter: 'DEPLOYER'\n                    }\n                }\n                echo \"üöÄ Deploying to production (approved by: ${env.DEPLOYER})...\"\n                script {\n                    sh '''\n                        # Production deployment with blue-green strategy\n                        CURRENT_CONTAINER=$(docker ps --filter \"name=${APP_NAME}-prod\" --format \"{{.Names}}\" || echo \"none\")\n                        \n                        if [ \"$CURRENT_CONTAINER\" != \"none\" ]; then\n                            echo \"Blue-green deployment: current container is $CURRENT_CONTAINER\"\n                            NEW_CONTAINER=\"${APP_NAME}-prod-blue\"\n                            OLD_CONTAINER=\"${APP_NAME}-prod\"\n                        else\n                            NEW_CONTAINER=\"${APP_NAME}-prod\"\n                            OLD_CONTAINER=\"none\"\n                        fi\n                        \n                        # Deploy new version\n                        docker run -d \\\n                            --name $NEW_CONTAINER \\\n                            --env-file .env.production \\\n                            -p 5002:5000 \\\n                            --restart unless-stopped \\\n                            ${DOCKER_IMAGE}\n                        \n                        # Wait and verify\n                        sleep 15\n                        curl -f http://localhost:5002/health | jq .\n                        \n                        # Switch traffic (in real scenarios, this would be done via load balancer)\n                        if [ \"$OLD_CONTAINER\" != \"none\" ]; then\n                            echo \"Stopping old container: $OLD_CONTAINER\"\n                            docker stop $OLD_CONTAINER || true\n                            docker rm $OLD_CONTAINER || true\n                        fi\n                        \n                        echo \"‚úÖ Production deployment successful!\"\n                        echo \"üåê Production URL: http://localhost:5002\"\n                    '''\n                }\n            }\n        }\n    }\n    \n    post {\n        always {\n            echo 'üßπ Cleaning up...'\n            script {\n                sh '''\n                    # Clean up pipeline artifacts\n                    rm -f .env.pipeline .env.docker || true\n                    \n                    # Clean up old Docker images (keep last 5 builds)\n                    docker images ${APP_NAME} --format \"table {{.Repository}}:{{.Tag}}\" | tail -n +6 | xargs -r docker rmi || true\n                    \n                    # Clean up dangling images\n                    docker image prune -f || true\n                '''\n            }\n        }\n        \n        success {\n            echo 'üéâ Pipeline completed successfully!'\n            script {\n                def message = '''\n‚úÖ **Build Successful** üéâ\n\n**Build Details:**\n- üì¶ Application: ''' + APP_NAME + '''\n- üî® Build: #''' + BUILD_NUMBER + '''\n- üìÖ Time: ''' + BUILD_TIMESTAMP + '''\n- üîó Commit: ''' + GIT_COMMIT_SHORT + '''\n- üåç Environment: ''' + env.NODE_ENV + '''\n- üê≥ Image: ''' + DOCKER_IMAGE + '''\n\n**Deployment:**\n''' + (params.DEPLOY_ENV != 'none' ? \n    '- üöÄ Deployed to: ' + params.DEPLOY_ENV + \n    '\\n- üåê URL: http://localhost:' + (params.DEPLOY_ENV == 'production' ? '5002' : '5001') \n    : '- üì¶ Built but not deployed') + '''\n\n**Next Steps:**\n- Monitor application health\n- Run additional tests if needed\n- Promote to next environment\n                '''\n                \n                echo message\n                \n                // In real scenarios, send notifications to Slack, email, etc.\n                // slackSend(channel: '#deployments', message: message)\n            }\n        }\n        \n        failure {\n            echo '‚ùå Pipeline failed!'\n            script {\n                def errorMessage = '''\n‚ùå **Build Failed** \n\n**Build Details:**\n- üì¶ Application: ''' + APP_NAME + '''\n- üî® Build: #''' + BUILD_NUMBER + '''\n- üìÖ Time: ''' + BUILD_TIMESTAMP + '''\n- üîó Commit: ''' + GIT_COMMIT_SHORT + '''\n- üåç Environment: ''' + env.NODE_ENV + '''\n\n**Action Required:**\n- Check build logs\n- Fix issues and retry\n- Contact DevOps team if needed\n                '''\n                \n                echo errorMessage\n                \n                // Send failure notifications\n                // slackSend(channel: '#alerts', message: errorMessage, color: 'danger')\n            }\n        }\n        \n        unstable {\n            echo '‚ö†Ô∏è Pipeline completed with warnings'\n        }\n    }\n}
